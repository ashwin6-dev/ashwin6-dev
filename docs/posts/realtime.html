<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="preload" href="/_next/static/css/78a96572e7124dae.css" as="style"/><link rel="stylesheet" href="/_next/static/css/78a96572e7124dae.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-65c92ea592d7dc99.js" defer=""></script><script src="/_next/static/chunks/framework-8bb630ac33a3f577.js" defer=""></script><script src="/_next/static/chunks/main-4e3d6004161c80ce.js" defer=""></script><script src="/_next/static/chunks/pages/_app-da15c11dea942c36.js" defer=""></script><script src="/_next/static/chunks/230-2e5eadefe0eacc40.js" defer=""></script><script src="/_next/static/chunks/78-eecbff2cf4ad13ad.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-5c059753b297bbf8.js" defer=""></script><script src="/_next/static/JBMdU8tQhzlgS9t7YQPhH/_buildManifest.js" defer=""></script><script src="/_next/static/JBMdU8tQhzlgS9t7YQPhH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="grid grid-cols-10"><div class="col-span-3 py-8"><div class="border mx-auto w-3/5 p-4 gap-4"><p class="text-xl font-bold mb-4">Mini Kahoot</p><a href="/posts/introduction"><div class="text-[grey]">1<!-- -->. <!-- -->Project Introduction</div></a><a href="/posts/project-breakdown"><div class="text-[grey]">2<!-- -->. <!-- -->Breaking It Down</div></a><a href="/posts/realtime"><div class="">3<!-- -->. <!-- -->HTTP &amp; The Magic Of Web Sockets</div></a><a href="/posts/api-design"><div class="text-[grey]">4<!-- -->. <!-- -->The Simple Art of API Design</div></a></div></div><div class="col-span-5"><div class="my-8"><a class="text-sm mb-4 underline" href="/series/Mini%20Kahoot">Back to series</a><p class="text-2xl font-bold tracking-tighter">HTTP &amp; The Magic Of Web Sockets</p><p>How can we communicate in realtime over the web?</p></div><div class="scrollbar overflow-y-auto max-h-[80vh] pr-4"><p class="leading-relaxed mb-4">Now that it&#x27;s time to think about implementation, one obvious question is how can we implement realtime communication
over the web.</p>
<h2 class="text-2xl font-semibold mt-5 mb-3">HTTP</h2>
<p class="leading-relaxed mb-4">The HTTP protocol is used by web applications as their primary communication method.</p>
<p class="leading-relaxed mb-4">It works on a <strong>request-response</strong> model which is simply:</p>
<ul class="list-disc ml-6 mb-4">
<li class="mb-2">Client sends a request to the web server.</li>
<li class="mb-2">The web server responds accordingly.</li>
<li class="mb-2">The connection closes.</li>
</ul>
<p class="leading-relaxed mb-4">This works great for many things on the web like submitting forms, fetching specific data, creating posts on social
media platforms etc.</p>
<p class="leading-relaxed mb-4">However, this request-response model means HTTP is a <strong>one-way</strong> communication protocol. Only the client can initiate
communication with the server. As you can probably imagine, this creates a problem when trying to build realtime
features.</p>
<p class="leading-relaxed mb-4">Realtime features require the server to be able to send data to the client without the client asking.</p>
<p class="leading-relaxed mb-4">For example, take a chat application like WhatsApp:</p>
<ul class="list-disc ml-6 mb-4">
<li class="mb-2">Two users are connected and chatting in real time.</li>
<li class="mb-2">When User A sends a message, it goes to the server.</li>
<li class="mb-2">The server now needs to deliver that message to User B.</li>
</ul>
<p class="leading-relaxed mb-4">But here&#x27;s the issue: with HTTP, only clients can initiate communication. That means User B won&#x27;t know there&#x27;s a new
message unless they <strong>actively send a request to check</strong>. Even then, when do they know to send the request?</p>
<p class="leading-relaxed mb-4">There a few solutions to this:</p>
<h3 class="text-xl font-semibold mt-5 mb-3">Polling</h3>
<p class="leading-relaxed mb-4">Polling is where the client simply sends a request at regular intervals to check for updates.</p>
<p class="leading-relaxed mb-4">This is simple to implement, yet this solution is very wasteful:</p>
<ul class="list-disc ml-6 mb-4">
<li class="mb-2">If multiple clients were connected and polling the web server, this would put unnecessary load on the server with most
polling requests likely returning no data.</li>
<li class="mb-2">Requests  are sent at fixed, regular intervals, there is a delay between data being available and received.</li>
<li class="mb-2">Full TCP handshakes are required for each request, introducing overhead &amp; latency.</li>
</ul>
<h3 class="text-xl font-semibold mt-5 mb-3">Long Polling</h3>
<p class="leading-relaxed mb-4">Long Polling is an improvement on Polling:</p>
<ul class="list-disc ml-6 mb-4">
<li class="mb-2">A client sends an HTTP request to the web server.</li>
<li class="mb-2">The web server keeps the connection open for a long/indefinite time period.</li>
<li class="mb-2">Once the server has the relevant data, it sends the response and closes the connection.</li>
</ul>
<p class="leading-relaxed mb-4">This reduces the number of connections made from Polling but still has issues:</p>
<ul class="list-disc ml-6 mb-4">
<li class="mb-2">Holding connections open is an inefficient use of server resources.</li>
<li class="mb-2">Handling connection timeouts and drops while ensuring messages are delivered consistently introduces complexity.</li>
<li class="mb-2">Scales poorly for several users.</li>
<li class="mb-2">Not truly bidirectional. Long Polling is just a hack around a one-way protocol.</li>
</ul>
<p class="leading-relaxed mb-4">Despite this, long polling can be useful:</p>
<ul class="list-disc ml-6 mb-4">
<li class="mb-2">Working on old systems or HTTP-only environments.</li>
<li class="mb-2">Realtime updates are infrequent.</li>
<li class="mb-2">Persistent connections are blocked.</li>
</ul>
<p class="leading-relaxed mb-4">Why exactly this is the case will make more sense when we talk about WebSockets...</p>
<h2 class="text-2xl font-semibold mt-5 mb-3">Web Sockets</h2>
<p class="leading-relaxed mb-4">WebSockets are the ideal solution for applications that need true, two-way communication between the client and server
which makes them perfect for applications with crucial realtime features like Mini Kahoot.</p>
<p class="leading-relaxed mb-4">WebSockets offer a different paradigm to what we have seen with the polling techniques. WebSockets establish a single,
long-lived connection between the client and server. Once its connection is established, data can flow freely in
both directions at any time, without the need for repeated requests.</p>
<p class="leading-relaxed mb-4">WebSockets improve on the polling techniques from before, effectively solving:</p>
<ul class="list-disc ml-6 mb-4">
<li class="mb-2"><strong>Reducing Latency:</strong> By maintaining a persistent connection, WebSockets eliminate the overhead of repeatedly
establishing new HTTP connections for each data exchange, significantly reducing latency.</li>
<li class="mb-2"><strong>Improving Efficiency:</strong> A single persistent connection consumes fewer resources compared to the constant
back-and-forth of polling or long-polling, especially in applications with frequent updates.</li>
<li class="mb-2"><strong>Enabling True Bidirectional Communication:</strong> WebSockets allow both the client and the server to initiate communication
at any point, facilitating richer and more interactive applications.</li>
</ul>
<p class="leading-relaxed mb-4">This long-lived connection is different from what happens in Long Polling - something that initially confused me when I
first learned about WebSockets was how it could be more efficient when both held long connections.</p>
<p class="leading-relaxed mb-4">In Long Polling, the connection closes as soon as the server responds with data (which
follows the standard behavior of HTTP). A new connection must then be created for the next update, introducing overhead.</p>
<p class="leading-relaxed mb-4">In contrast, WebSockets use a separate, lightweight protocol that keeps the connection open even after data is sent, only
closing when the client or server explicitly decides to end it.</p>
<h2 class="text-2xl font-semibold mt-5 mb-3">WebSockets Under The Hood</h2>
<p class="leading-relaxed mb-4">Let&#x27;s dive into exactly how WebSockets provide true, bidirectional communication over the web.</p>
<h3 class="text-xl font-semibold mt-5 mb-3">WebSocket Open Handshake</h3>
<p class="leading-relaxed mb-4">The aim of this handshake is to upgrade the existing HTTP connection to a WebSocket connection.</p>
<p class="leading-relaxed mb-4">WebSockets start as a standard HTTP request and response. In this interaction, the client asks to open a WebSocket
connection and, if it is able to, the server responds, successfully completing the handshake.</p>
<p class="leading-relaxed mb-4">The handshake follows these steps:</p>
<h3 class="text-xl font-semibold mt-5 mb-3">1. Client Request</h3>
<p class="leading-relaxed mb-4">The client sends a HTTP GET request to a WebSocket URI. WebSocket URIs look the same to HTTP URIs, except they begin
with a <code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">ws:</code> or <code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">wss:</code> (secure web socket) instead of <code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">http:</code> or <code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">https:</code></p>
<p class="leading-relaxed mb-4">The request includes the following headers:</p>
<p class="leading-relaxed mb-4"><code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Connection: Upgrade</code> indicates we want to use a different protocol to HTTP.</p>
<p class="leading-relaxed mb-4"><code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Upgrade: websocket</code> The <code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Upgrade</code> header in general is used to switch the connection to the given protocol. It
could be a list of protocols also, which specify decreasing order of preference for the protocol switch.</p>
<p class="leading-relaxed mb-4"><code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</code> The <code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Sec-WebSocket-Key</code> is a random 16-byte value that has been
base64-encoded. Its use will be explained later.</p>
<p class="leading-relaxed mb-4"><code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Sec-WebSocket-Version: 13</code> Currently, the only accepted version of the WebSocket protocol is 13. No other version
will work.</p>
<h3 class="text-xl font-semibold mt-5 mb-3">2. Server Response</h3>
<p class="leading-relaxed mb-4">The server response is a HTTP 101 Switching Protocols response and includes the the following headers:</p>
<p class="leading-relaxed mb-4"><code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Connection: Upgrade</code> Confirms that the connection has been upgraded.</p>
<p class="leading-relaxed mb-4"><code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Upgrade: websocket</code> Confirms that the connection has been upgraded.</p>
<p class="leading-relaxed mb-4"><code class="bg-gray-200 text-black text-sm px-1 py-0.5 rounded">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code> This value is computed by concatenating
258EAFA5-E914-47DA-95CA-C5AB0DC85B11 to the key received from the client and performing a SHA-1 hash followed by a
Base64 encode on the result. The client performs the same algorithm on the key it sent earlier, ensuring the computed
values match. This prevents malicious users from tricking servers into treating non-WebSocket connections as WebSocket
connections, which could lead to unpredictable behaviour.</p>
<p class="leading-relaxed mb-4">After the server response, the handshake is complete and the client and server have agreed to use the existing TCP/IP
connection established for the HTTP request as a WebSocket connection. Data can flow both ways in this connection via a
simple framed protocol.</p></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"realtime","title":"HTTP \u0026 The Magic Of Web Sockets","date":"2025-19-05","description":"How can we communicate in realtime over the web?","series":"Mini Kahoot","part":3,"content":"\r\nNow that it's time to think about implementation, one obvious question is how can we implement realtime communication\r\nover the web.\r\n\r\n## HTTP\r\n\r\nThe HTTP protocol is used by web applications as their primary communication method. \r\n\r\nIt works on a **request-response** model which is simply:\r\n* Client sends a request to the web server.\r\n* The web server responds accordingly.\r\n* The connection closes.\r\n\r\nThis works great for many things on the web like submitting forms, fetching specific data, creating posts on social\r\nmedia platforms etc.\r\n\r\nHowever, this request-response model means HTTP is a **one-way** communication protocol. Only the client can initiate\r\ncommunication with the server. As you can probably imagine, this creates a problem when trying to build realtime\r\nfeatures.\r\n\r\nRealtime features require the server to be able to send data to the client without the client asking. \r\n\r\nFor example, take a chat application like WhatsApp:\r\n\r\n* Two users are connected and chatting in real time.\r\n* When User A sends a message, it goes to the server.\r\n* The server now needs to deliver that message to User B.\r\n\r\nBut here's the issue: with HTTP, only clients can initiate communication. That means User B won't know there's a new \r\nmessage unless they **actively send a request to check**. Even then, when do they know to send the request?\r\n\r\nThere a few solutions to this:\r\n\r\n### Polling\r\n\r\nPolling is where the client simply sends a request at regular intervals to check for updates.\r\n\r\nThis is simple to implement, yet this solution is very wasteful:\r\n* If multiple clients were connected and polling the web server, this would put unnecessary load on the server with most \r\npolling requests likely returning no data. \r\n* Requests  are sent at fixed, regular intervals, there is a delay between data being available and received. \r\n* Full TCP handshakes are required for each request, introducing overhead \u0026 latency.\r\n\r\n### Long Polling\r\n\r\nLong Polling is an improvement on Polling: \r\n* A client sends an HTTP request to the web server. \r\n* The web server keeps the connection open for a long/indefinite time period.\r\n* Once the server has the relevant data, it sends the response and closes the connection.\r\n\r\nThis reduces the number of connections made from Polling but still has issues:\r\n* Holding connections open is an inefficient use of server resources.\r\n* Handling connection timeouts and drops while ensuring messages are delivered consistently introduces complexity.\r\n* Scales poorly for several users.\r\n* Not truly bidirectional. Long Polling is just a hack around a one-way protocol.\r\n\r\nDespite this, long polling can be useful:\r\n* Working on old systems or HTTP-only environments.\r\n* Realtime updates are infrequent.\r\n* Persistent connections are blocked.\r\n\r\nWhy exactly this is the case will make more sense when we talk about WebSockets...\r\n\r\n## Web Sockets\r\n\r\nWebSockets are the ideal solution for applications that need true, two-way communication between the client and server \r\nwhich makes them perfect for applications with crucial realtime features like Mini Kahoot.\r\n\r\nWebSockets offer a different paradigm to what we have seen with the polling techniques. WebSockets establish a single, \r\nlong-lived connection between the client and server. Once its connection is established, data can flow freely in \r\nboth directions at any time, without the need for repeated requests.\r\n\r\n\r\nWebSockets improve on the polling techniques from before, effectively solving:\r\n* **Reducing Latency:** By maintaining a persistent connection, WebSockets eliminate the overhead of repeatedly \r\nestablishing new HTTP connections for each data exchange, significantly reducing latency.\r\n* **Improving Efficiency:** A single persistent connection consumes fewer resources compared to the constant \r\nback-and-forth of polling or long-polling, especially in applications with frequent updates. \r\n* **Enabling True Bidirectional Communication:** WebSockets allow both the client and the server to initiate communication \r\nat any point, facilitating richer and more interactive applications.\r\n\r\nThis long-lived connection is different from what happens in Long Polling - something that initially confused me when I\r\nfirst learned about WebSockets was how it could be more efficient when both held long connections. \r\n\r\nIn Long Polling, the connection closes as soon as the server responds with data (which\r\nfollows the standard behavior of HTTP). A new connection must then be created for the next update, introducing overhead.\r\n\r\nIn contrast, WebSockets use a separate, lightweight protocol that keeps the connection open even after data is sent, only \r\nclosing when the client or server explicitly decides to end it.\r\n\r\n## WebSockets Under The Hood\r\n\r\nLet's dive into exactly how WebSockets provide true, bidirectional communication over the web.\r\n\r\n### WebSocket Open Handshake\r\n\r\nThe aim of this handshake is to upgrade the existing HTTP connection to a WebSocket connection.\r\n\r\nWebSockets start as a standard HTTP request and response. In this interaction, the client asks to open a WebSocket \r\nconnection and, if it is able to, the server responds, successfully completing the handshake.\r\n\r\nThe handshake follows these steps:\r\n\r\n### 1. Client Request\r\n\r\nThe client sends a HTTP GET request to a WebSocket URI. WebSocket URIs look the same to HTTP URIs, except they begin \r\nwith a ```ws:``` or ```wss:``` (secure web socket) instead of ```http:``` or ```https:```\r\n\r\nThe request includes the following headers:\r\n\r\n```Connection: Upgrade``` indicates we want to use a different protocol to HTTP.\r\n\r\n```Upgrade: websocket``` The ```Upgrade``` header in general is used to switch the connection to the given protocol. It \r\ncould be a list of protocols also, which specify decreasing order of preference for the protocol switch.\r\n\r\n```Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==``` The ```Sec-WebSocket-Key``` is a random 16-byte value that has been \r\nbase64-encoded. Its use will be explained later.\r\n\r\n```Sec-WebSocket-Version: 13``` Currently, the only accepted version of the WebSocket protocol is 13. No other version \r\nwill work.\r\n\r\n### 2. Server Response\r\n\r\nThe server response is a HTTP 101 Switching Protocols response and includes the the following headers:\r\n\r\n```Connection: Upgrade``` Confirms that the connection has been upgraded.\r\n\r\n```Upgrade: websocket``` Confirms that the connection has been upgraded.\r\n\r\n```Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=``` This value is computed by concatenating \r\n258EAFA5-E914-47DA-95CA-C5AB0DC85B11 to the key received from the client and performing a SHA-1 hash followed by a \r\nBase64 encode on the result. The client performs the same algorithm on the key it sent earlier, ensuring the computed \r\nvalues match. This prevents malicious users from tricking servers into treating non-WebSocket connections as WebSocket \r\nconnections, which could lead to unpredictable behaviour.\r\n\r\nAfter the server response, the handshake is complete and the client and server have agreed to use the existing TCP/IP \r\nconnection established for the HTTP request as a WebSocket connection. Data can flow both ways in this connection via a \r\nsimple framed protocol."},"series":{"name":"Mini Kahoot","description":"Building a Kahoot clone using React, NestJS, MongoDB and Huggingface.","posts":[{"id":"introduction","title":"Project Introduction","date":"2025-19-05","description":"What am I building \u0026 aim of the series.","series":"Mini Kahoot","part":1},{"id":"project-breakdown","title":"Breaking It Down","date":"2025-19-05","description":"Breaking the project down into a clear specification","series":"Mini Kahoot","part":2},{"id":"realtime","title":"HTTP \u0026 The Magic Of Web Sockets","date":"2025-19-05","description":"How can we communicate in realtime over the web?","series":"Mini Kahoot","part":3},{"id":"api-design","title":"The Simple Art of API Design","date":"2025-05-19","description":"What makes a good API?","series":"Mini Kahoot","part":4}]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"realtime"},"buildId":"JBMdU8tQhzlgS9t7YQPhH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>