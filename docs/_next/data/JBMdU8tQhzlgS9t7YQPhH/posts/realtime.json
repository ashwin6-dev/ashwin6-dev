{"pageProps":{"post":{"id":"realtime","title":"HTTP & The Magic Of Web Sockets","date":"2025-19-05","description":"How can we communicate in realtime over the web?","series":"Mini Kahoot","part":3,"content":"\r\nNow that it's time to think about implementation, one obvious question is how can we implement realtime communication\r\nover the web.\r\n\r\n## HTTP\r\n\r\nThe HTTP protocol is used by web applications as their primary communication method. \r\n\r\nIt works on a **request-response** model which is simply:\r\n* Client sends a request to the web server.\r\n* The web server responds accordingly.\r\n* The connection closes.\r\n\r\nThis works great for many things on the web like submitting forms, fetching specific data, creating posts on social\r\nmedia platforms etc.\r\n\r\nHowever, this request-response model means HTTP is a **one-way** communication protocol. Only the client can initiate\r\ncommunication with the server. As you can probably imagine, this creates a problem when trying to build realtime\r\nfeatures.\r\n\r\nRealtime features require the server to be able to send data to the client without the client asking. \r\n\r\nFor example, take a chat application like WhatsApp:\r\n\r\n* Two users are connected and chatting in real time.\r\n* When User A sends a message, it goes to the server.\r\n* The server now needs to deliver that message to User B.\r\n\r\nBut here's the issue: with HTTP, only clients can initiate communication. That means User B won't know there's a new \r\nmessage unless they **actively send a request to check**. Even then, when do they know to send the request?\r\n\r\nThere a few solutions to this:\r\n\r\n### Polling\r\n\r\nPolling is where the client simply sends a request at regular intervals to check for updates.\r\n\r\nThis is simple to implement, yet this solution is very wasteful:\r\n* If multiple clients were connected and polling the web server, this would put unnecessary load on the server with most \r\npolling requests likely returning no data. \r\n* Requests  are sent at fixed, regular intervals, there is a delay between data being available and received. \r\n* Full TCP handshakes are required for each request, introducing overhead & latency.\r\n\r\n### Long Polling\r\n\r\nLong Polling is an improvement on Polling: \r\n* A client sends an HTTP request to the web server. \r\n* The web server keeps the connection open for a long/indefinite time period.\r\n* Once the server has the relevant data, it sends the response and closes the connection.\r\n\r\nThis reduces the number of connections made from Polling but still has issues:\r\n* Holding connections open is an inefficient use of server resources.\r\n* Handling connection timeouts and drops while ensuring messages are delivered consistently introduces complexity.\r\n* Scales poorly for several users.\r\n* Not truly bidirectional. Long Polling is just a hack around a one-way protocol.\r\n\r\nDespite this, long polling can be useful:\r\n* Working on old systems or HTTP-only environments.\r\n* Realtime updates are infrequent.\r\n* Persistent connections are blocked.\r\n\r\nWhy exactly this is the case will make more sense when we talk about WebSockets...\r\n\r\n## Web Sockets\r\n\r\nWebSockets are the ideal solution for applications that need true, two-way communication between the client and server \r\nwhich makes them perfect for applications with crucial realtime features like Mini Kahoot.\r\n\r\nWebSockets offer a different paradigm to what we have seen with the polling techniques. WebSockets establish a single, \r\nlong-lived connection between the client and server. Once its connection is established, data can flow freely in \r\nboth directions at any time, without the need for repeated requests.\r\n\r\n\r\nWebSockets improve on the polling techniques from before, effectively solving:\r\n* **Reducing Latency:** By maintaining a persistent connection, WebSockets eliminate the overhead of repeatedly \r\nestablishing new HTTP connections for each data exchange, significantly reducing latency.\r\n* **Improving Efficiency:** A single persistent connection consumes fewer resources compared to the constant \r\nback-and-forth of polling or long-polling, especially in applications with frequent updates. \r\n* **Enabling True Bidirectional Communication:** WebSockets allow both the client and the server to initiate communication \r\nat any point, facilitating richer and more interactive applications.\r\n\r\nThis long-lived connection is different from what happens in Long Polling - something that initially confused me when I\r\nfirst learned about WebSockets was how it could be more efficient when both held long connections. \r\n\r\nIn Long Polling, the connection closes as soon as the server responds with data (which\r\nfollows the standard behavior of HTTP). A new connection must then be created for the next update, introducing overhead.\r\n\r\nIn contrast, WebSockets use a separate, lightweight protocol that keeps the connection open even after data is sent, only \r\nclosing when the client or server explicitly decides to end it.\r\n\r\n## WebSockets Under The Hood\r\n\r\nLet's dive into exactly how WebSockets provide true, bidirectional communication over the web.\r\n\r\n### WebSocket Open Handshake\r\n\r\nThe aim of this handshake is to upgrade the existing HTTP connection to a WebSocket connection.\r\n\r\nWebSockets start as a standard HTTP request and response. In this interaction, the client asks to open a WebSocket \r\nconnection and, if it is able to, the server responds, successfully completing the handshake.\r\n\r\nThe handshake follows these steps:\r\n\r\n### 1. Client Request\r\n\r\nThe client sends a HTTP GET request to a WebSocket URI. WebSocket URIs look the same to HTTP URIs, except they begin \r\nwith a ```ws:``` or ```wss:``` (secure web socket) instead of ```http:``` or ```https:```\r\n\r\nThe request includes the following headers:\r\n\r\n```Connection: Upgrade``` indicates we want to use a different protocol to HTTP.\r\n\r\n```Upgrade: websocket``` The ```Upgrade``` header in general is used to switch the connection to the given protocol. It \r\ncould be a list of protocols also, which specify decreasing order of preference for the protocol switch.\r\n\r\n```Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==``` The ```Sec-WebSocket-Key``` is a random 16-byte value that has been \r\nbase64-encoded. Its use will be explained later.\r\n\r\n```Sec-WebSocket-Version: 13``` Currently, the only accepted version of the WebSocket protocol is 13. No other version \r\nwill work.\r\n\r\n### 2. Server Response\r\n\r\nThe server response is a HTTP 101 Switching Protocols response and includes the the following headers:\r\n\r\n```Connection: Upgrade``` Confirms that the connection has been upgraded.\r\n\r\n```Upgrade: websocket``` Confirms that the connection has been upgraded.\r\n\r\n```Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=``` This value is computed by concatenating \r\n258EAFA5-E914-47DA-95CA-C5AB0DC85B11 to the key received from the client and performing a SHA-1 hash followed by a \r\nBase64 encode on the result. The client performs the same algorithm on the key it sent earlier, ensuring the computed \r\nvalues match. This prevents malicious users from tricking servers into treating non-WebSocket connections as WebSocket \r\nconnections, which could lead to unpredictable behaviour.\r\n\r\nAfter the server response, the handshake is complete and the client and server have agreed to use the existing TCP/IP \r\nconnection established for the HTTP request as a WebSocket connection. Data can flow both ways in this connection via a \r\nsimple framed protocol."},"series":{"name":"Mini Kahoot","description":"Building a Kahoot clone using React, NestJS, MongoDB and Huggingface.","posts":[{"id":"introduction","title":"Project Introduction","date":"2025-19-05","description":"What am I building & aim of the series.","series":"Mini Kahoot","part":1},{"id":"project-breakdown","title":"Breaking It Down","date":"2025-19-05","description":"Breaking the project down into a clear specification","series":"Mini Kahoot","part":2},{"id":"realtime","title":"HTTP & The Magic Of Web Sockets","date":"2025-19-05","description":"How can we communicate in realtime over the web?","series":"Mini Kahoot","part":3},{"id":"api-design","title":"The Simple Art of API Design","date":"2025-05-19","description":"What makes a good API?","series":"Mini Kahoot","part":4}]}},"__N_SSG":true}